<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Https Linking</title>
</head>

<body>
    <h1>HTTPS底层原理</h1>
    <p>
        <h2>（1）两种加密类型</h2>
        <p>
            【对称加密】：客户端使用相同的密钥加密和解密数据，服务端也用相同的密钥解密和加密数据。
            <br> 【非对称加密】：含公钥和私钥，客户端使用公钥加密数据，服务端使用私钥揭秘数据，一份公钥只有对应的私钥才能解密。
        </p>
        <h2>（2）CA认证证书申请</h2>
        <p>
            私钥根据你提供的域名、公司名称、部门、省份、城市等信息来生成一份待签名的公钥（CSR证书），
            <br> 然后把这个公钥提交到CA证书中心去完成签名流程， CA使用它自己的私钥加密CSR证书，该流程完成后，
            <br> CA会交给你一份CRT证书，里面包含了CA签名，公钥过期日期，申请人提交的信息。
            <br> 将CRT证书和私钥部署在你的服务器上，该服务器就是HTTP服务器了。
        </p>
        <h2>（3）证书验证流程</h2>
        <p>
            一般来说，CA证书验证程序都是内置在系统当中的。
            <br> 首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，
            <br> 校验证书是否在有效期内，浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，
            <br> 来与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发，如果找不到，
            <br> 浏览器就会报错，说明服务器发来的证书是不可信任的。
            <br> 如果找到，那么浏览器就会从操作系统中取出颁发者CA的公钥（多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥），
            <br> 然后使用该公钥对由服务器发来的证书中的签名进行解密，浏览器使用相同的hash算法计算由服务器发来的证书的hash值，
            <br> 然后将这个计算的hash值与证书中签名做对比，如果对比结果一致，则证明服务器发来的证书合法，没有被冒充。
        </p>
        <h2>（4）握手流程</h2>
        <p>
            <h3>【单向认证】：</h3>
            <p>
                1.第一次握手：客户端请求浏览器的时候，会携带客户端支持的加密算法，给服务器端。
                <br> 2.第二次握手：服务器端收到客户端的请求后，选择一种客户端支持的加密算法，并连同当前服务端的CRT证书一起发送给客户端。
                <br> 3.第三次握手：客户端收到服务端下发的证书，并验证这个证书是合法的证书，然后根据服务器发送来的加密算法，生成一个随机的密钥，使用这个密钥加密数据生成密文，
                <br> 然后把这个密钥和密文，再用服务端发送过来的公钥进行加密，再把加密好的密文和的密钥一起发送给服务端。（公钥加密，公钥解不开，第三方拿到公钥，也解不开公钥加密的数据）
                <br> 4.第四次握手：服务端拿到由客户端加密后发过来的密文和密钥，因为服务端它有私钥，所以说它能对密钥进行解密，并拿到里面的密钥，然后使用密钥对密文解密，取出数据。（服务端的私钥是一定不能丢的）
            </p>
            <h3>【双向认证】：</h3>
            <p>
                1.第一次握手：客户端请求浏览器的时候，会携带客户端支持的加密算法、客户端CRT证书，发送给服务器端。
                <br> 2.第二次握手：服务器端收到客户端的请求后，使用CA的公钥解密客户端CRT证书，拿到客户端公钥，然后选择和客户端共有的解密算法，使用客户端的公钥加密，最后将当前服务端的CRT证书以及加密后的算法发送给客户端。
                <br> 3.第三次握手：客户端收到服务端下发的证书，并验证这个证书是合法的证书。然后客户端使用自己的私钥解密由服务端发送来的加密算法，生成一个随机密钥，使用这个密钥加密数据生成密文，
                <br> 再用服务端发送过来的公钥进行加密，再将加密好的密文和加密算法一起发送给服务端。（公钥加密，公钥解不开，第三方拿到公钥，也解不开公钥加密的数据）
                <br> 4.第四次握手：服务端拿到客户端发过来的密文，因为服务端它有私钥，所以说它能解开密文，并拿到里面的密钥。（服务端的私钥是一定不能丢的）
                <br>
            </p>
        </p>
    </p>
</body>

</html>